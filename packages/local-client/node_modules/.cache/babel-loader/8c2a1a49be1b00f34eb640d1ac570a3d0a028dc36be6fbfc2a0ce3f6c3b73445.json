{"ast":null,"code":"(function (Prism) {\n  var javascript = Prism.util.clone(Prism.languages.javascript);\n  var space = /(?:\\s|\\/\\/.*(?!.)|\\/\\*(?:[^*]|\\*(?!\\/))\\*\\/)/.source;\n  var braces = /(?:\\{(?:\\{(?:\\{[^{}]*\\}|[^{}])*\\}|[^{}])*\\})/.source;\n  var spread = /(?:\\{<S>*\\.{3}(?:[^{}]|<BRACES>)*\\})/.source;\n\n  /**\r\n   * @param {string} source\r\n   * @param {string} [flags]\r\n   */\n  function re(source, flags) {\n    source = source.replace(/<S>/g, function () {\n      return space;\n    }).replace(/<BRACES>/g, function () {\n      return braces;\n    }).replace(/<SPREAD>/g, function () {\n      return spread;\n    });\n    return RegExp(source, flags);\n  }\n  spread = re(spread).source;\n  Prism.languages.jsx = Prism.languages.extend('markup', javascript);\n  Prism.languages.jsx.tag.pattern = re(/<\\/?(?:[\\w.:-]+(?:<S>+(?:[\\w.:$-]+(?:=(?:\"(?:\\\\[\\s\\S]|[^\\\\\"])*\"|'(?:\\\\[\\s\\S]|[^\\\\'])*'|[^\\s{'\"/>=]+|<BRACES>))?|<SPREAD>))*<S>*\\/?)?>/.source);\n  Prism.languages.jsx.tag.inside['tag'].pattern = /^<\\/?[^\\s>\\/]*/i;\n  Prism.languages.jsx.tag.inside['attr-value'].pattern = /=(?!\\{)(?:\"(?:\\\\[\\s\\S]|[^\\\\\"])*\"|'(?:\\\\[\\s\\S]|[^\\\\'])*'|[^\\s'\">]+)/i;\n  Prism.languages.jsx.tag.inside['tag'].inside['class-name'] = /^[A-Z]\\w*(?:\\.[A-Z]\\w*)*$/;\n  Prism.languages.jsx.tag.inside['comment'] = javascript['comment'];\n  Prism.languages.insertBefore('inside', 'attr-name', {\n    'spread': {\n      pattern: re(/<SPREAD>/.source),\n      inside: Prism.languages.jsx\n    }\n  }, Prism.languages.jsx.tag);\n  Prism.languages.insertBefore('inside', 'special-attr', {\n    'script': {\n      // Allow for two levels of nesting\n      pattern: re(/=<BRACES>/.source),\n      inside: {\n        'script-punctuation': {\n          pattern: /^=(?=\\{)/,\n          alias: 'punctuation'\n        },\n        rest: Prism.languages.jsx\n      },\n      'alias': 'language-javascript'\n    }\n  }, Prism.languages.jsx.tag);\n\n  // The following will handle plain text inside tags\n  var stringifyToken = function (token) {\n    if (!token) {\n      return '';\n    }\n    if (typeof token === 'string') {\n      return token;\n    }\n    if (typeof token.content === 'string') {\n      return token.content;\n    }\n    return token.content.map(stringifyToken).join('');\n  };\n  var walkTokens = function (tokens) {\n    var openedTags = [];\n    for (var i = 0; i < tokens.length; i++) {\n      var token = tokens[i];\n      var notTagNorBrace = false;\n      if (typeof token !== 'string') {\n        if (token.type === 'tag' && token.content[0] && token.content[0].type === 'tag') {\n          // We found a tag, now find its kind\n\n          if (token.content[0].content[0].content === '</') {\n            // Closing tag\n            if (openedTags.length > 0 && openedTags[openedTags.length - 1].tagName === stringifyToken(token.content[0].content[1])) {\n              // Pop matching opening tag\n              openedTags.pop();\n            }\n          } else {\n            if (token.content[token.content.length - 1].content === '/>') {\n              // Autoclosed tag, ignore\n            } else {\n              // Opening tag\n              openedTags.push({\n                tagName: stringifyToken(token.content[0].content[1]),\n                openedBraces: 0\n              });\n            }\n          }\n        } else if (openedTags.length > 0 && token.type === 'punctuation' && token.content === '{') {\n          // Here we might have entered a JSX context inside a tag\n          openedTags[openedTags.length - 1].openedBraces++;\n        } else if (openedTags.length > 0 && openedTags[openedTags.length - 1].openedBraces > 0 && token.type === 'punctuation' && token.content === '}') {\n          // Here we might have left a JSX context inside a tag\n          openedTags[openedTags.length - 1].openedBraces--;\n        } else {\n          notTagNorBrace = true;\n        }\n      }\n      if (notTagNorBrace || typeof token === 'string') {\n        if (openedTags.length > 0 && openedTags[openedTags.length - 1].openedBraces === 0) {\n          // Here we are inside a tag, and not inside a JSX context.\n          // That's plain text: drop any tokens matched.\n          var plainText = stringifyToken(token);\n\n          // And merge text with adjacent text\n          if (i < tokens.length - 1 && (typeof tokens[i + 1] === 'string' || tokens[i + 1].type === 'plain-text')) {\n            plainText += stringifyToken(tokens[i + 1]);\n            tokens.splice(i + 1, 1);\n          }\n          if (i > 0 && (typeof tokens[i - 1] === 'string' || tokens[i - 1].type === 'plain-text')) {\n            plainText = stringifyToken(tokens[i - 1]) + plainText;\n            tokens.splice(i - 1, 1);\n            i--;\n          }\n          tokens[i] = new Prism.Token('plain-text', plainText, null, plainText);\n        }\n      }\n      if (token.content && typeof token.content !== 'string') {\n        walkTokens(token.content);\n      }\n    }\n  };\n  Prism.hooks.add('after-tokenize', function (env) {\n    if (env.language !== 'jsx' && env.language !== 'tsx') {\n      return;\n    }\n    walkTokens(env.tokens);\n  });\n})(Prism);","map":{"version":3,"names":["Prism","javascript","util","clone","languages","space","source","braces","spread","re","flags","replace","RegExp","jsx","extend","tag","pattern","inside","insertBefore","alias","rest","stringifyToken","token","content","map","join","walkTokens","tokens","openedTags","i","length","notTagNorBrace","type","tagName","pop","push","openedBraces","plainText","splice","Token","hooks","add","env","language"],"sources":["C:/Users/Maya/Desktop/AWT/podokumentowane/podokumentowane/packages/local-client/node_modules/prismjs/components/prism-jsx.js"],"sourcesContent":["(function (Prism) {\r\n\r\n\tvar javascript = Prism.util.clone(Prism.languages.javascript);\r\n\r\n\tvar space = /(?:\\s|\\/\\/.*(?!.)|\\/\\*(?:[^*]|\\*(?!\\/))\\*\\/)/.source;\r\n\tvar braces = /(?:\\{(?:\\{(?:\\{[^{}]*\\}|[^{}])*\\}|[^{}])*\\})/.source;\r\n\tvar spread = /(?:\\{<S>*\\.{3}(?:[^{}]|<BRACES>)*\\})/.source;\r\n\r\n\t/**\r\n\t * @param {string} source\r\n\t * @param {string} [flags]\r\n\t */\r\n\tfunction re(source, flags) {\r\n\t\tsource = source\r\n\t\t\t.replace(/<S>/g, function () { return space; })\r\n\t\t\t.replace(/<BRACES>/g, function () { return braces; })\r\n\t\t\t.replace(/<SPREAD>/g, function () { return spread; });\r\n\t\treturn RegExp(source, flags);\r\n\t}\r\n\r\n\tspread = re(spread).source;\r\n\r\n\r\n\tPrism.languages.jsx = Prism.languages.extend('markup', javascript);\r\n\tPrism.languages.jsx.tag.pattern = re(\r\n\t\t/<\\/?(?:[\\w.:-]+(?:<S>+(?:[\\w.:$-]+(?:=(?:\"(?:\\\\[\\s\\S]|[^\\\\\"])*\"|'(?:\\\\[\\s\\S]|[^\\\\'])*'|[^\\s{'\"/>=]+|<BRACES>))?|<SPREAD>))*<S>*\\/?)?>/.source\r\n\t);\r\n\r\n\tPrism.languages.jsx.tag.inside['tag'].pattern = /^<\\/?[^\\s>\\/]*/i;\r\n\tPrism.languages.jsx.tag.inside['attr-value'].pattern = /=(?!\\{)(?:\"(?:\\\\[\\s\\S]|[^\\\\\"])*\"|'(?:\\\\[\\s\\S]|[^\\\\'])*'|[^\\s'\">]+)/i;\r\n\tPrism.languages.jsx.tag.inside['tag'].inside['class-name'] = /^[A-Z]\\w*(?:\\.[A-Z]\\w*)*$/;\r\n\tPrism.languages.jsx.tag.inside['comment'] = javascript['comment'];\r\n\r\n\tPrism.languages.insertBefore('inside', 'attr-name', {\r\n\t\t'spread': {\r\n\t\t\tpattern: re(/<SPREAD>/.source),\r\n\t\t\tinside: Prism.languages.jsx\r\n\t\t}\r\n\t}, Prism.languages.jsx.tag);\r\n\r\n\tPrism.languages.insertBefore('inside', 'special-attr', {\r\n\t\t'script': {\r\n\t\t\t// Allow for two levels of nesting\r\n\t\t\tpattern: re(/=<BRACES>/.source),\r\n\t\t\tinside: {\r\n\t\t\t\t'script-punctuation': {\r\n\t\t\t\t\tpattern: /^=(?=\\{)/,\r\n\t\t\t\t\talias: 'punctuation'\r\n\t\t\t\t},\r\n\t\t\t\trest: Prism.languages.jsx\r\n\t\t\t},\r\n\t\t\t'alias': 'language-javascript'\r\n\t\t}\r\n\t}, Prism.languages.jsx.tag);\r\n\r\n\t// The following will handle plain text inside tags\r\n\tvar stringifyToken = function (token) {\r\n\t\tif (!token) {\r\n\t\t\treturn '';\r\n\t\t}\r\n\t\tif (typeof token === 'string') {\r\n\t\t\treturn token;\r\n\t\t}\r\n\t\tif (typeof token.content === 'string') {\r\n\t\t\treturn token.content;\r\n\t\t}\r\n\t\treturn token.content.map(stringifyToken).join('');\r\n\t};\r\n\r\n\tvar walkTokens = function (tokens) {\r\n\t\tvar openedTags = [];\r\n\t\tfor (var i = 0; i < tokens.length; i++) {\r\n\t\t\tvar token = tokens[i];\r\n\t\t\tvar notTagNorBrace = false;\r\n\r\n\t\t\tif (typeof token !== 'string') {\r\n\t\t\t\tif (token.type === 'tag' && token.content[0] && token.content[0].type === 'tag') {\r\n\t\t\t\t\t// We found a tag, now find its kind\r\n\r\n\t\t\t\t\tif (token.content[0].content[0].content === '</') {\r\n\t\t\t\t\t\t// Closing tag\r\n\t\t\t\t\t\tif (openedTags.length > 0 && openedTags[openedTags.length - 1].tagName === stringifyToken(token.content[0].content[1])) {\r\n\t\t\t\t\t\t\t// Pop matching opening tag\r\n\t\t\t\t\t\t\topenedTags.pop();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tif (token.content[token.content.length - 1].content === '/>') {\r\n\t\t\t\t\t\t\t// Autoclosed tag, ignore\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t// Opening tag\r\n\t\t\t\t\t\t\topenedTags.push({\r\n\t\t\t\t\t\t\t\ttagName: stringifyToken(token.content[0].content[1]),\r\n\t\t\t\t\t\t\t\topenedBraces: 0\r\n\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if (openedTags.length > 0 && token.type === 'punctuation' && token.content === '{') {\r\n\r\n\t\t\t\t\t// Here we might have entered a JSX context inside a tag\r\n\t\t\t\t\topenedTags[openedTags.length - 1].openedBraces++;\r\n\r\n\t\t\t\t} else if (openedTags.length > 0 && openedTags[openedTags.length - 1].openedBraces > 0 && token.type === 'punctuation' && token.content === '}') {\r\n\r\n\t\t\t\t\t// Here we might have left a JSX context inside a tag\r\n\t\t\t\t\topenedTags[openedTags.length - 1].openedBraces--;\r\n\r\n\t\t\t\t} else {\r\n\t\t\t\t\tnotTagNorBrace = true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (notTagNorBrace || typeof token === 'string') {\r\n\t\t\t\tif (openedTags.length > 0 && openedTags[openedTags.length - 1].openedBraces === 0) {\r\n\t\t\t\t\t// Here we are inside a tag, and not inside a JSX context.\r\n\t\t\t\t\t// That's plain text: drop any tokens matched.\r\n\t\t\t\t\tvar plainText = stringifyToken(token);\r\n\r\n\t\t\t\t\t// And merge text with adjacent text\r\n\t\t\t\t\tif (i < tokens.length - 1 && (typeof tokens[i + 1] === 'string' || tokens[i + 1].type === 'plain-text')) {\r\n\t\t\t\t\t\tplainText += stringifyToken(tokens[i + 1]);\r\n\t\t\t\t\t\ttokens.splice(i + 1, 1);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (i > 0 && (typeof tokens[i - 1] === 'string' || tokens[i - 1].type === 'plain-text')) {\r\n\t\t\t\t\t\tplainText = stringifyToken(tokens[i - 1]) + plainText;\r\n\t\t\t\t\t\ttokens.splice(i - 1, 1);\r\n\t\t\t\t\t\ti--;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\ttokens[i] = new Prism.Token('plain-text', plainText, null, plainText);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (token.content && typeof token.content !== 'string') {\r\n\t\t\t\twalkTokens(token.content);\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\r\n\tPrism.hooks.add('after-tokenize', function (env) {\r\n\t\tif (env.language !== 'jsx' && env.language !== 'tsx') {\r\n\t\t\treturn;\r\n\t\t}\r\n\t\twalkTokens(env.tokens);\r\n\t});\r\n\r\n}(Prism));\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}