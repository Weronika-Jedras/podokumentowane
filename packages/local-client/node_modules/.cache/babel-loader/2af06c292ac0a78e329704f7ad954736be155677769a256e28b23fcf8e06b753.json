{"ast":null,"code":"(function (Prism) {\n  Prism.languages.xquery = Prism.languages.extend('markup', {\n    'xquery-comment': {\n      pattern: /\\(:[\\s\\S]*?:\\)/,\n      greedy: true,\n      alias: 'comment'\n    },\n    'string': {\n      pattern: /([\"'])(?:\\1\\1|(?!\\1)[\\s\\S])*\\1/,\n      greedy: true\n    },\n    'extension': {\n      pattern: /\\(#.+?#\\)/,\n      alias: 'symbol'\n    },\n    'variable': /\\$[-\\w:]+/,\n    'axis': {\n      pattern: /(^|[^-])(?:ancestor(?:-or-self)?|attribute|child|descendant(?:-or-self)?|following(?:-sibling)?|parent|preceding(?:-sibling)?|self)(?=::)/,\n      lookbehind: true,\n      alias: 'operator'\n    },\n    'keyword-operator': {\n      pattern: /(^|[^:-])\\b(?:and|castable as|div|eq|except|ge|gt|idiv|instance of|intersect|is|le|lt|mod|ne|or|union)\\b(?=$|[^:-])/,\n      lookbehind: true,\n      alias: 'operator'\n    },\n    'keyword': {\n      pattern: /(^|[^:-])\\b(?:as|ascending|at|base-uri|boundary-space|case|cast as|collation|construction|copy-namespaces|declare|default|descending|else|empty (?:greatest|least)|encoding|every|external|for|function|if|import|in|inherit|lax|let|map|module|namespace|no-inherit|no-preserve|option|order(?: by|ed|ing)?|preserve|return|satisfies|schema|some|stable|strict|strip|then|to|treat as|typeswitch|unordered|validate|variable|version|where|xquery)\\b(?=$|[^:-])/,\n      lookbehind: true\n    },\n    'function': /[\\w-]+(?::[\\w-]+)*(?=\\s*\\()/,\n    'xquery-element': {\n      pattern: /(element\\s+)[\\w-]+(?::[\\w-]+)*/,\n      lookbehind: true,\n      alias: 'tag'\n    },\n    'xquery-attribute': {\n      pattern: /(attribute\\s+)[\\w-]+(?::[\\w-]+)*/,\n      lookbehind: true,\n      alias: 'attr-name'\n    },\n    'builtin': {\n      pattern: /(^|[^:-])\\b(?:attribute|comment|document|element|processing-instruction|text|xs:(?:anyAtomicType|anyType|anyURI|base64Binary|boolean|byte|date|dateTime|dayTimeDuration|decimal|double|duration|ENTITIES|ENTITY|float|gDay|gMonth|gMonthDay|gYear|gYearMonth|hexBinary|ID|IDREFS?|int|integer|language|long|Name|NCName|negativeInteger|NMTOKENS?|nonNegativeInteger|nonPositiveInteger|normalizedString|NOTATION|positiveInteger|QName|short|string|time|token|unsigned(?:Byte|Int|Long|Short)|untyped(?:Atomic)?|yearMonthDuration))\\b(?=$|[^:-])/,\n      lookbehind: true\n    },\n    'number': /\\b\\d+(?:\\.\\d+)?(?:E[+-]?\\d+)?/,\n    'operator': [/[+*=?|@]|\\.\\.?|:=|!=|<[=<]?|>[=>]?/, {\n      pattern: /(\\s)-(?=\\s)/,\n      lookbehind: true\n    }],\n    'punctuation': /[[\\](){},;:/]/\n  });\n  Prism.languages.xquery.tag.pattern = /<\\/?(?!\\d)[^\\s>\\/=$<%]+(?:\\s+[^\\s>\\/=]+(?:=(?:(\"|')(?:\\\\[\\s\\S]|\\{(?!\\{)(?:\\{(?:\\{[^{}]*\\}|[^{}])*\\}|[^{}])+\\}|(?!\\1)[^\\\\])*\\1|[^\\s'\">=]+))?)*\\s*\\/?>/i;\n  Prism.languages.xquery['tag'].inside['attr-value'].pattern = /=(?:(\"|')(?:\\\\[\\s\\S]|\\{(?!\\{)(?:\\{(?:\\{[^{}]*\\}|[^{}])*\\}|[^{}])+\\}|(?!\\1)[^\\\\])*\\1|[^\\s'\">=]+)/i;\n  Prism.languages.xquery['tag'].inside['attr-value'].inside['punctuation'] = /^=\"|\"$/;\n  Prism.languages.xquery['tag'].inside['attr-value'].inside['expression'] = {\n    // Allow for two levels of nesting\n    pattern: /\\{(?!\\{)(?:\\{(?:\\{[^{}]*\\}|[^{}])*\\}|[^{}])+\\}/,\n    inside: Prism.languages.xquery,\n    alias: 'language-xquery'\n  };\n\n  // The following will handle plain text inside tags\n  var stringifyToken = function (token) {\n    if (typeof token === 'string') {\n      return token;\n    }\n    if (typeof token.content === 'string') {\n      return token.content;\n    }\n    return token.content.map(stringifyToken).join('');\n  };\n  var walkTokens = function (tokens) {\n    var openedTags = [];\n    for (var i = 0; i < tokens.length; i++) {\n      var token = tokens[i];\n      var notTagNorBrace = false;\n      if (typeof token !== 'string') {\n        if (token.type === 'tag' && token.content[0] && token.content[0].type === 'tag') {\n          // We found a tag, now find its kind\n\n          if (token.content[0].content[0].content === '</') {\n            // Closing tag\n            if (openedTags.length > 0 && openedTags[openedTags.length - 1].tagName === stringifyToken(token.content[0].content[1])) {\n              // Pop matching opening tag\n              openedTags.pop();\n            }\n          } else {\n            if (token.content[token.content.length - 1].content === '/>') {\n              // Autoclosed tag, ignore\n            } else {\n              // Opening tag\n              openedTags.push({\n                tagName: stringifyToken(token.content[0].content[1]),\n                openedBraces: 0\n              });\n            }\n          }\n        } else if (openedTags.length > 0 && token.type === 'punctuation' && token.content === '{' && (\n        // Ignore `{{`\n        !tokens[i + 1] || tokens[i + 1].type !== 'punctuation' || tokens[i + 1].content !== '{') && (!tokens[i - 1] || tokens[i - 1].type !== 'plain-text' || tokens[i - 1].content !== '{')) {\n          // Here we might have entered an XQuery expression inside a tag\n          openedTags[openedTags.length - 1].openedBraces++;\n        } else if (openedTags.length > 0 && openedTags[openedTags.length - 1].openedBraces > 0 && token.type === 'punctuation' && token.content === '}') {\n          // Here we might have left an XQuery expression inside a tag\n          openedTags[openedTags.length - 1].openedBraces--;\n        } else if (token.type !== 'comment') {\n          notTagNorBrace = true;\n        }\n      }\n      if (notTagNorBrace || typeof token === 'string') {\n        if (openedTags.length > 0 && openedTags[openedTags.length - 1].openedBraces === 0) {\n          // Here we are inside a tag, and not inside an XQuery expression.\n          // That's plain text: drop any tokens matched.\n          var plainText = stringifyToken(token);\n\n          // And merge text with adjacent text\n          if (i < tokens.length - 1 && (typeof tokens[i + 1] === 'string' || tokens[i + 1].type === 'plain-text')) {\n            plainText += stringifyToken(tokens[i + 1]);\n            tokens.splice(i + 1, 1);\n          }\n          if (i > 0 && (typeof tokens[i - 1] === 'string' || tokens[i - 1].type === 'plain-text')) {\n            plainText = stringifyToken(tokens[i - 1]) + plainText;\n            tokens.splice(i - 1, 1);\n            i--;\n          }\n          if (/^\\s+$/.test(plainText)) {\n            tokens[i] = plainText;\n          } else {\n            tokens[i] = new Prism.Token('plain-text', plainText, null, plainText);\n          }\n        }\n      }\n      if (token.content && typeof token.content !== 'string') {\n        walkTokens(token.content);\n      }\n    }\n  };\n  Prism.hooks.add('after-tokenize', function (env) {\n    if (env.language !== 'xquery') {\n      return;\n    }\n    walkTokens(env.tokens);\n  });\n})(Prism);","map":{"version":3,"names":["Prism","languages","xquery","extend","pattern","greedy","alias","lookbehind","tag","inside","stringifyToken","token","content","map","join","walkTokens","tokens","openedTags","i","length","notTagNorBrace","type","tagName","pop","push","openedBraces","plainText","splice","test","Token","hooks","add","env","language"],"sources":["C:/Users/Maya/Desktop/AWT/podokumentowane/podokumentowane/packages/local-client/node_modules/prismjs/components/prism-xquery.js"],"sourcesContent":["(function (Prism) {\r\n\r\n\tPrism.languages.xquery = Prism.languages.extend('markup', {\r\n\t\t'xquery-comment': {\r\n\t\t\tpattern: /\\(:[\\s\\S]*?:\\)/,\r\n\t\t\tgreedy: true,\r\n\t\t\talias: 'comment'\r\n\t\t},\r\n\t\t'string': {\r\n\t\t\tpattern: /([\"'])(?:\\1\\1|(?!\\1)[\\s\\S])*\\1/,\r\n\t\t\tgreedy: true\r\n\t\t},\r\n\t\t'extension': {\r\n\t\t\tpattern: /\\(#.+?#\\)/,\r\n\t\t\talias: 'symbol'\r\n\t\t},\r\n\t\t'variable': /\\$[-\\w:]+/,\r\n\t\t'axis': {\r\n\t\t\tpattern: /(^|[^-])(?:ancestor(?:-or-self)?|attribute|child|descendant(?:-or-self)?|following(?:-sibling)?|parent|preceding(?:-sibling)?|self)(?=::)/,\r\n\t\t\tlookbehind: true,\r\n\t\t\talias: 'operator'\r\n\t\t},\r\n\t\t'keyword-operator': {\r\n\t\t\tpattern: /(^|[^:-])\\b(?:and|castable as|div|eq|except|ge|gt|idiv|instance of|intersect|is|le|lt|mod|ne|or|union)\\b(?=$|[^:-])/,\r\n\t\t\tlookbehind: true,\r\n\t\t\talias: 'operator'\r\n\t\t},\r\n\t\t'keyword': {\r\n\t\t\tpattern: /(^|[^:-])\\b(?:as|ascending|at|base-uri|boundary-space|case|cast as|collation|construction|copy-namespaces|declare|default|descending|else|empty (?:greatest|least)|encoding|every|external|for|function|if|import|in|inherit|lax|let|map|module|namespace|no-inherit|no-preserve|option|order(?: by|ed|ing)?|preserve|return|satisfies|schema|some|stable|strict|strip|then|to|treat as|typeswitch|unordered|validate|variable|version|where|xquery)\\b(?=$|[^:-])/,\r\n\t\t\tlookbehind: true\r\n\t\t},\r\n\t\t'function': /[\\w-]+(?::[\\w-]+)*(?=\\s*\\()/,\r\n\t\t'xquery-element': {\r\n\t\t\tpattern: /(element\\s+)[\\w-]+(?::[\\w-]+)*/,\r\n\t\t\tlookbehind: true,\r\n\t\t\talias: 'tag'\r\n\t\t},\r\n\t\t'xquery-attribute': {\r\n\t\t\tpattern: /(attribute\\s+)[\\w-]+(?::[\\w-]+)*/,\r\n\t\t\tlookbehind: true,\r\n\t\t\talias: 'attr-name'\r\n\t\t},\r\n\t\t'builtin': {\r\n\t\t\tpattern: /(^|[^:-])\\b(?:attribute|comment|document|element|processing-instruction|text|xs:(?:anyAtomicType|anyType|anyURI|base64Binary|boolean|byte|date|dateTime|dayTimeDuration|decimal|double|duration|ENTITIES|ENTITY|float|gDay|gMonth|gMonthDay|gYear|gYearMonth|hexBinary|ID|IDREFS?|int|integer|language|long|Name|NCName|negativeInteger|NMTOKENS?|nonNegativeInteger|nonPositiveInteger|normalizedString|NOTATION|positiveInteger|QName|short|string|time|token|unsigned(?:Byte|Int|Long|Short)|untyped(?:Atomic)?|yearMonthDuration))\\b(?=$|[^:-])/,\r\n\t\t\tlookbehind: true\r\n\t\t},\r\n\t\t'number': /\\b\\d+(?:\\.\\d+)?(?:E[+-]?\\d+)?/,\r\n\t\t'operator': [\r\n\t\t\t/[+*=?|@]|\\.\\.?|:=|!=|<[=<]?|>[=>]?/,\r\n\t\t\t{\r\n\t\t\t\tpattern: /(\\s)-(?=\\s)/,\r\n\t\t\t\tlookbehind: true\r\n\t\t\t}\r\n\t\t],\r\n\t\t'punctuation': /[[\\](){},;:/]/\r\n\t});\r\n\r\n\tPrism.languages.xquery.tag.pattern = /<\\/?(?!\\d)[^\\s>\\/=$<%]+(?:\\s+[^\\s>\\/=]+(?:=(?:(\"|')(?:\\\\[\\s\\S]|\\{(?!\\{)(?:\\{(?:\\{[^{}]*\\}|[^{}])*\\}|[^{}])+\\}|(?!\\1)[^\\\\])*\\1|[^\\s'\">=]+))?)*\\s*\\/?>/i;\r\n\tPrism.languages.xquery['tag'].inside['attr-value'].pattern = /=(?:(\"|')(?:\\\\[\\s\\S]|\\{(?!\\{)(?:\\{(?:\\{[^{}]*\\}|[^{}])*\\}|[^{}])+\\}|(?!\\1)[^\\\\])*\\1|[^\\s'\">=]+)/i;\r\n\tPrism.languages.xquery['tag'].inside['attr-value'].inside['punctuation'] = /^=\"|\"$/;\r\n\tPrism.languages.xquery['tag'].inside['attr-value'].inside['expression'] = {\r\n\t\t// Allow for two levels of nesting\r\n\t\tpattern: /\\{(?!\\{)(?:\\{(?:\\{[^{}]*\\}|[^{}])*\\}|[^{}])+\\}/,\r\n\t\tinside: Prism.languages.xquery,\r\n\t\talias: 'language-xquery'\r\n\t};\r\n\r\n\t// The following will handle plain text inside tags\r\n\tvar stringifyToken = function (token) {\r\n\t\tif (typeof token === 'string') {\r\n\t\t\treturn token;\r\n\t\t}\r\n\t\tif (typeof token.content === 'string') {\r\n\t\t\treturn token.content;\r\n\t\t}\r\n\t\treturn token.content.map(stringifyToken).join('');\r\n\t};\r\n\r\n\tvar walkTokens = function (tokens) {\r\n\t\tvar openedTags = [];\r\n\t\tfor (var i = 0; i < tokens.length; i++) {\r\n\t\t\tvar token = tokens[i];\r\n\t\t\tvar notTagNorBrace = false;\r\n\r\n\t\t\tif (typeof token !== 'string') {\r\n\t\t\t\tif (token.type === 'tag' && token.content[0] && token.content[0].type === 'tag') {\r\n\t\t\t\t\t// We found a tag, now find its kind\r\n\r\n\t\t\t\t\tif (token.content[0].content[0].content === '</') {\r\n\t\t\t\t\t\t// Closing tag\r\n\t\t\t\t\t\tif (openedTags.length > 0 && openedTags[openedTags.length - 1].tagName === stringifyToken(token.content[0].content[1])) {\r\n\t\t\t\t\t\t\t// Pop matching opening tag\r\n\t\t\t\t\t\t\topenedTags.pop();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tif (token.content[token.content.length - 1].content === '/>') {\r\n\t\t\t\t\t\t\t// Autoclosed tag, ignore\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t// Opening tag\r\n\t\t\t\t\t\t\topenedTags.push({\r\n\t\t\t\t\t\t\t\ttagName: stringifyToken(token.content[0].content[1]),\r\n\t\t\t\t\t\t\t\topenedBraces: 0\r\n\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if (\r\n\t\t\t\t\topenedTags.length > 0 && token.type === 'punctuation' && token.content === '{' &&\r\n\t\t\t\t\t// Ignore `{{`\r\n\t\t\t\t\t(!tokens[i + 1] || tokens[i + 1].type !== 'punctuation' || tokens[i + 1].content !== '{') &&\r\n\t\t\t\t\t(!tokens[i - 1] || tokens[i - 1].type !== 'plain-text' || tokens[i - 1].content !== '{')\r\n\t\t\t\t) {\r\n\t\t\t\t\t// Here we might have entered an XQuery expression inside a tag\r\n\t\t\t\t\topenedTags[openedTags.length - 1].openedBraces++;\r\n\r\n\t\t\t\t} else if (openedTags.length > 0 && openedTags[openedTags.length - 1].openedBraces > 0 && token.type === 'punctuation' && token.content === '}') {\r\n\r\n\t\t\t\t\t// Here we might have left an XQuery expression inside a tag\r\n\t\t\t\t\topenedTags[openedTags.length - 1].openedBraces--;\r\n\r\n\t\t\t\t} else if (token.type !== 'comment') {\r\n\t\t\t\t\tnotTagNorBrace = true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (notTagNorBrace || typeof token === 'string') {\r\n\t\t\t\tif (openedTags.length > 0 && openedTags[openedTags.length - 1].openedBraces === 0) {\r\n\t\t\t\t\t// Here we are inside a tag, and not inside an XQuery expression.\r\n\t\t\t\t\t// That's plain text: drop any tokens matched.\r\n\t\t\t\t\tvar plainText = stringifyToken(token);\r\n\r\n\t\t\t\t\t// And merge text with adjacent text\r\n\t\t\t\t\tif (i < tokens.length - 1 && (typeof tokens[i + 1] === 'string' || tokens[i + 1].type === 'plain-text')) {\r\n\t\t\t\t\t\tplainText += stringifyToken(tokens[i + 1]);\r\n\t\t\t\t\t\ttokens.splice(i + 1, 1);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (i > 0 && (typeof tokens[i - 1] === 'string' || tokens[i - 1].type === 'plain-text')) {\r\n\t\t\t\t\t\tplainText = stringifyToken(tokens[i - 1]) + plainText;\r\n\t\t\t\t\t\ttokens.splice(i - 1, 1);\r\n\t\t\t\t\t\ti--;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (/^\\s+$/.test(plainText)) {\r\n\t\t\t\t\t\ttokens[i] = plainText;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\ttokens[i] = new Prism.Token('plain-text', plainText, null, plainText);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (token.content && typeof token.content !== 'string') {\r\n\t\t\t\twalkTokens(token.content);\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\r\n\tPrism.hooks.add('after-tokenize', function (env) {\r\n\t\tif (env.language !== 'xquery') {\r\n\t\t\treturn;\r\n\t\t}\r\n\t\twalkTokens(env.tokens);\r\n\t});\r\n\r\n}(Prism));\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}