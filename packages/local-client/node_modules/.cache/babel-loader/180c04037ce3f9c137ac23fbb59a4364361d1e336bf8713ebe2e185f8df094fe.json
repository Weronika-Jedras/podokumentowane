{"ast":null,"code":"(function (Prism) {\n  var templateString = Prism.languages.javascript['template-string'];\n\n  // see the pattern in prism-javascript.js\n  var templateLiteralPattern = templateString.pattern.source;\n  var interpolationObject = templateString.inside['interpolation'];\n  var interpolationPunctuationObject = interpolationObject.inside['interpolation-punctuation'];\n  var interpolationPattern = interpolationObject.pattern.source;\n\n  /**\r\n   * Creates a new pattern to match a template string with a special tag.\r\n   *\r\n   * This will return `undefined` if there is no grammar with the given language id.\r\n   *\r\n   * @param {string} language The language id of the embedded language. E.g. `markdown`.\r\n   * @param {string} tag The regex pattern to match the tag.\r\n   * @returns {object | undefined}\r\n   * @example\r\n   * createTemplate('css', /\\bcss/.source);\r\n   */\n  function createTemplate(language, tag) {\n    if (!Prism.languages[language]) {\n      return undefined;\n    }\n    return {\n      pattern: RegExp('((?:' + tag + ')\\\\s*)' + templateLiteralPattern),\n      lookbehind: true,\n      greedy: true,\n      inside: {\n        'template-punctuation': {\n          pattern: /^`|`$/,\n          alias: 'string'\n        },\n        'embedded-code': {\n          pattern: /[\\s\\S]+/,\n          alias: language\n        }\n      }\n    };\n  }\n  Prism.languages.javascript['template-string'] = [\n  // styled-jsx:\n  //   css`a { color: #25F; }`\n  // styled-components:\n  //   styled.h1`color: red;`\n  createTemplate('css', /\\b(?:styled(?:\\([^)]*\\))?(?:\\s*\\.\\s*\\w+(?:\\([^)]*\\))*)*|css(?:\\s*\\.\\s*(?:global|resolve))?|createGlobalStyle|keyframes)/.source),\n  // html`<p></p>`\n  // div.innerHTML = `<p></p>`\n  createTemplate('html', /\\bhtml|\\.\\s*(?:inner|outer)HTML\\s*\\+?=/.source),\n  // svg`<path fill=\"#fff\" d=\"M55.37 ...\"/>`\n  createTemplate('svg', /\\bsvg/.source),\n  // md`# h1`, markdown`## h2`\n  createTemplate('markdown', /\\b(?:md|markdown)/.source),\n  // gql`...`, graphql`...`, graphql.experimental`...`\n  createTemplate('graphql', /\\b(?:gql|graphql(?:\\s*\\.\\s*experimental)?)/.source),\n  // sql`...`\n  createTemplate('sql', /\\bsql/.source),\n  // vanilla template string\n  templateString].filter(Boolean);\n\n  /**\r\n   * Returns a specific placeholder literal for the given language.\r\n   *\r\n   * @param {number} counter\r\n   * @param {string} language\r\n   * @returns {string}\r\n   */\n  function getPlaceholder(counter, language) {\n    return '___' + language.toUpperCase() + '_' + counter + '___';\n  }\n\n  /**\r\n   * Returns the tokens of `Prism.tokenize` but also runs the `before-tokenize` and `after-tokenize` hooks.\r\n   *\r\n   * @param {string} code\r\n   * @param {any} grammar\r\n   * @param {string} language\r\n   * @returns {(string|Token)[]}\r\n   */\n  function tokenizeWithHooks(code, grammar, language) {\n    var env = {\n      code: code,\n      grammar: grammar,\n      language: language\n    };\n    Prism.hooks.run('before-tokenize', env);\n    env.tokens = Prism.tokenize(env.code, env.grammar);\n    Prism.hooks.run('after-tokenize', env);\n    return env.tokens;\n  }\n\n  /**\r\n   * Returns the token of the given JavaScript interpolation expression.\r\n   *\r\n   * @param {string} expression The code of the expression. E.g. `\"${42}\"`\r\n   * @returns {Token}\r\n   */\n  function tokenizeInterpolationExpression(expression) {\n    var tempGrammar = {};\n    tempGrammar['interpolation-punctuation'] = interpolationPunctuationObject;\n\n    /** @type {Array} */\n    var tokens = Prism.tokenize(expression, tempGrammar);\n    if (tokens.length === 3) {\n      /**\r\n       * The token array will look like this\r\n       * [\r\n       *     [\"interpolation-punctuation\", \"${\"]\r\n       *     \"...\" // JavaScript expression of the interpolation\r\n       *     [\"interpolation-punctuation\", \"}\"]\r\n       * ]\r\n       */\n\n      var args = [1, 1];\n      args.push.apply(args, tokenizeWithHooks(tokens[1], Prism.languages.javascript, 'javascript'));\n      tokens.splice.apply(tokens, args);\n    }\n    return new Prism.Token('interpolation', tokens, interpolationObject.alias, expression);\n  }\n\n  /**\r\n   * Tokenizes the given code with support for JavaScript interpolation expressions mixed in.\r\n   *\r\n   * This function has 3 phases:\r\n   *\r\n   * 1. Replace all JavaScript interpolation expression with a placeholder.\r\n   *    The placeholder will have the syntax of a identify of the target language.\r\n   * 2. Tokenize the code with placeholders.\r\n   * 3. Tokenize the interpolation expressions and re-insert them into the tokenize code.\r\n   *    The insertion only works if a placeholder hasn't been \"ripped apart\" meaning that the placeholder has been\r\n   *    tokenized as two tokens by the grammar of the embedded language.\r\n   *\r\n   * @param {string} code\r\n   * @param {object} grammar\r\n   * @param {string} language\r\n   * @returns {Token}\r\n   */\n  function tokenizeEmbedded(code, grammar, language) {\n    // 1. First filter out all interpolations\n\n    // because they might be escaped, we need a lookbehind, so we use Prism\n    /** @type {(Token|string)[]} */\n    var _tokens = Prism.tokenize(code, {\n      'interpolation': {\n        pattern: RegExp(interpolationPattern),\n        lookbehind: true\n      }\n    });\n\n    // replace all interpolations with a placeholder which is not in the code already\n    var placeholderCounter = 0;\n    /** @type {Object<string, string>} */\n    var placeholderMap = {};\n    var embeddedCode = _tokens.map(function (token) {\n      if (typeof token === 'string') {\n        return token;\n      } else {\n        var interpolationExpression = token.content;\n        var placeholder;\n        while (code.indexOf(placeholder = getPlaceholder(placeholderCounter++, language)) !== -1) {/* noop */}\n        placeholderMap[placeholder] = interpolationExpression;\n        return placeholder;\n      }\n    }).join('');\n\n    // 2. Tokenize the embedded code\n\n    var embeddedTokens = tokenizeWithHooks(embeddedCode, grammar, language);\n\n    // 3. Re-insert the interpolation\n\n    var placeholders = Object.keys(placeholderMap);\n    placeholderCounter = 0;\n\n    /**\r\n     *\r\n     * @param {(Token|string)[]} tokens\r\n     * @returns {void}\r\n     */\n    function walkTokens(tokens) {\n      for (var i = 0; i < tokens.length; i++) {\n        if (placeholderCounter >= placeholders.length) {\n          return;\n        }\n        var token = tokens[i];\n        if (typeof token === 'string' || typeof token.content === 'string') {\n          var placeholder = placeholders[placeholderCounter];\n          var s = typeof token === 'string' ? token : /** @type {string} */token.content;\n          var index = s.indexOf(placeholder);\n          if (index !== -1) {\n            ++placeholderCounter;\n            var before = s.substring(0, index);\n            var middle = tokenizeInterpolationExpression(placeholderMap[placeholder]);\n            var after = s.substring(index + placeholder.length);\n            var replacement = [];\n            if (before) {\n              replacement.push(before);\n            }\n            replacement.push(middle);\n            if (after) {\n              var afterTokens = [after];\n              walkTokens(afterTokens);\n              replacement.push.apply(replacement, afterTokens);\n            }\n            if (typeof token === 'string') {\n              tokens.splice.apply(tokens, [i, 1].concat(replacement));\n              i += replacement.length - 1;\n            } else {\n              token.content = replacement;\n            }\n          }\n        } else {\n          var content = token.content;\n          if (Array.isArray(content)) {\n            walkTokens(content);\n          } else {\n            walkTokens([content]);\n          }\n        }\n      }\n    }\n    walkTokens(embeddedTokens);\n    return new Prism.Token(language, embeddedTokens, 'language-' + language, code);\n  }\n\n  /**\r\n   * The languages for which JS templating will handle tagged template literals.\r\n   *\r\n   * JS templating isn't active for only JavaScript but also related languages like TypeScript, JSX, and TSX.\r\n   */\n  var supportedLanguages = {\n    'javascript': true,\n    'js': true,\n    'typescript': true,\n    'ts': true,\n    'jsx': true,\n    'tsx': true\n  };\n  Prism.hooks.add('after-tokenize', function (env) {\n    if (!(env.language in supportedLanguages)) {\n      return;\n    }\n\n    /**\r\n     * Finds and tokenizes all template strings with an embedded languages.\r\n     *\r\n     * @param {(Token | string)[]} tokens\r\n     * @returns {void}\r\n     */\n    function findTemplateStrings(tokens) {\n      for (var i = 0, l = tokens.length; i < l; i++) {\n        var token = tokens[i];\n        if (typeof token === 'string') {\n          continue;\n        }\n        var content = token.content;\n        if (!Array.isArray(content)) {\n          if (typeof content !== 'string') {\n            findTemplateStrings([content]);\n          }\n          continue;\n        }\n        if (token.type === 'template-string') {\n          /**\r\n           * A JavaScript template-string token will look like this:\r\n           *\r\n           * [\"template-string\", [\r\n           *     [\"template-punctuation\", \"`\"],\r\n           *     (\r\n           *         An array of \"string\" and \"interpolation\" tokens. This is the simple string case.\r\n           *         or\r\n           *         [\"embedded-code\", \"...\"] This is the token containing the embedded code.\r\n           *                                  It also has an alias which is the language of the embedded code.\r\n           *     ),\r\n           *     [\"template-punctuation\", \"`\"]\r\n           * ]]\r\n           */\n\n          var embedded = content[1];\n          if (content.length === 3 && typeof embedded !== 'string' && embedded.type === 'embedded-code') {\n            // get string content\n            var code = stringContent(embedded);\n            var alias = embedded.alias;\n            var language = Array.isArray(alias) ? alias[0] : alias;\n            var grammar = Prism.languages[language];\n            if (!grammar) {\n              // the embedded language isn't registered.\n              continue;\n            }\n            content[1] = tokenizeEmbedded(code, grammar, language);\n          }\n        } else {\n          findTemplateStrings(content);\n        }\n      }\n    }\n    findTemplateStrings(env.tokens);\n  });\n\n  /**\r\n   * Returns the string content of a token or token stream.\r\n   *\r\n   * @param {string | Token | (string | Token)[]} value\r\n   * @returns {string}\r\n   */\n  function stringContent(value) {\n    if (typeof value === 'string') {\n      return value;\n    } else if (Array.isArray(value)) {\n      return value.map(stringContent).join('');\n    } else {\n      return stringContent(value.content);\n    }\n  }\n})(Prism);","map":{"version":3,"names":["Prism","templateString","languages","javascript","templateLiteralPattern","pattern","source","interpolationObject","inside","interpolationPunctuationObject","interpolationPattern","createTemplate","language","tag","undefined","RegExp","lookbehind","greedy","alias","filter","Boolean","getPlaceholder","counter","toUpperCase","tokenizeWithHooks","code","grammar","env","hooks","run","tokens","tokenize","tokenizeInterpolationExpression","expression","tempGrammar","length","args","push","apply","splice","Token","tokenizeEmbedded","_tokens","placeholderCounter","placeholderMap","embeddedCode","map","token","interpolationExpression","content","placeholder","indexOf","join","embeddedTokens","placeholders","Object","keys","walkTokens","i","s","index","before","substring","middle","after","replacement","afterTokens","concat","Array","isArray","supportedLanguages","add","findTemplateStrings","l","type","embedded","stringContent","value"],"sources":["C:/Users/Maya/Desktop/AWT/podokumentowane/podokumentowane/packages/local-client/node_modules/prismjs/components/prism-js-templates.js"],"sourcesContent":["(function (Prism) {\r\n\r\n\tvar templateString = Prism.languages.javascript['template-string'];\r\n\r\n\t// see the pattern in prism-javascript.js\r\n\tvar templateLiteralPattern = templateString.pattern.source;\r\n\tvar interpolationObject = templateString.inside['interpolation'];\r\n\tvar interpolationPunctuationObject = interpolationObject.inside['interpolation-punctuation'];\r\n\tvar interpolationPattern = interpolationObject.pattern.source;\r\n\r\n\r\n\t/**\r\n\t * Creates a new pattern to match a template string with a special tag.\r\n\t *\r\n\t * This will return `undefined` if there is no grammar with the given language id.\r\n\t *\r\n\t * @param {string} language The language id of the embedded language. E.g. `markdown`.\r\n\t * @param {string} tag The regex pattern to match the tag.\r\n\t * @returns {object | undefined}\r\n\t * @example\r\n\t * createTemplate('css', /\\bcss/.source);\r\n\t */\r\n\tfunction createTemplate(language, tag) {\r\n\t\tif (!Prism.languages[language]) {\r\n\t\t\treturn undefined;\r\n\t\t}\r\n\r\n\t\treturn {\r\n\t\t\tpattern: RegExp('((?:' + tag + ')\\\\s*)' + templateLiteralPattern),\r\n\t\t\tlookbehind: true,\r\n\t\t\tgreedy: true,\r\n\t\t\tinside: {\r\n\t\t\t\t'template-punctuation': {\r\n\t\t\t\t\tpattern: /^`|`$/,\r\n\t\t\t\t\talias: 'string'\r\n\t\t\t\t},\r\n\t\t\t\t'embedded-code': {\r\n\t\t\t\t\tpattern: /[\\s\\S]+/,\r\n\t\t\t\t\talias: language\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\t}\r\n\r\n\r\n\tPrism.languages.javascript['template-string'] = [\r\n\t\t// styled-jsx:\r\n\t\t//   css`a { color: #25F; }`\r\n\t\t// styled-components:\r\n\t\t//   styled.h1`color: red;`\r\n\t\tcreateTemplate('css', /\\b(?:styled(?:\\([^)]*\\))?(?:\\s*\\.\\s*\\w+(?:\\([^)]*\\))*)*|css(?:\\s*\\.\\s*(?:global|resolve))?|createGlobalStyle|keyframes)/.source),\r\n\r\n\t\t// html`<p></p>`\r\n\t\t// div.innerHTML = `<p></p>`\r\n\t\tcreateTemplate('html', /\\bhtml|\\.\\s*(?:inner|outer)HTML\\s*\\+?=/.source),\r\n\r\n\t\t// svg`<path fill=\"#fff\" d=\"M55.37 ...\"/>`\r\n\t\tcreateTemplate('svg', /\\bsvg/.source),\r\n\r\n\t\t// md`# h1`, markdown`## h2`\r\n\t\tcreateTemplate('markdown', /\\b(?:md|markdown)/.source),\r\n\r\n\t\t// gql`...`, graphql`...`, graphql.experimental`...`\r\n\t\tcreateTemplate('graphql', /\\b(?:gql|graphql(?:\\s*\\.\\s*experimental)?)/.source),\r\n\r\n\t\t// sql`...`\r\n\t\tcreateTemplate('sql', /\\bsql/.source),\r\n\r\n\t\t// vanilla template string\r\n\t\ttemplateString\r\n\t].filter(Boolean);\r\n\r\n\r\n\t/**\r\n\t * Returns a specific placeholder literal for the given language.\r\n\t *\r\n\t * @param {number} counter\r\n\t * @param {string} language\r\n\t * @returns {string}\r\n\t */\r\n\tfunction getPlaceholder(counter, language) {\r\n\t\treturn '___' + language.toUpperCase() + '_' + counter + '___';\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the tokens of `Prism.tokenize` but also runs the `before-tokenize` and `after-tokenize` hooks.\r\n\t *\r\n\t * @param {string} code\r\n\t * @param {any} grammar\r\n\t * @param {string} language\r\n\t * @returns {(string|Token)[]}\r\n\t */\r\n\tfunction tokenizeWithHooks(code, grammar, language) {\r\n\t\tvar env = {\r\n\t\t\tcode: code,\r\n\t\t\tgrammar: grammar,\r\n\t\t\tlanguage: language\r\n\t\t};\r\n\t\tPrism.hooks.run('before-tokenize', env);\r\n\t\tenv.tokens = Prism.tokenize(env.code, env.grammar);\r\n\t\tPrism.hooks.run('after-tokenize', env);\r\n\t\treturn env.tokens;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the token of the given JavaScript interpolation expression.\r\n\t *\r\n\t * @param {string} expression The code of the expression. E.g. `\"${42}\"`\r\n\t * @returns {Token}\r\n\t */\r\n\tfunction tokenizeInterpolationExpression(expression) {\r\n\t\tvar tempGrammar = {};\r\n\t\ttempGrammar['interpolation-punctuation'] = interpolationPunctuationObject;\r\n\r\n\t\t/** @type {Array} */\r\n\t\tvar tokens = Prism.tokenize(expression, tempGrammar);\r\n\t\tif (tokens.length === 3) {\r\n\t\t\t/**\r\n\t\t\t * The token array will look like this\r\n\t\t\t * [\r\n\t\t\t *     [\"interpolation-punctuation\", \"${\"]\r\n\t\t\t *     \"...\" // JavaScript expression of the interpolation\r\n\t\t\t *     [\"interpolation-punctuation\", \"}\"]\r\n\t\t\t * ]\r\n\t\t\t */\r\n\r\n\t\t\tvar args = [1, 1];\r\n\t\t\targs.push.apply(args, tokenizeWithHooks(tokens[1], Prism.languages.javascript, 'javascript'));\r\n\r\n\t\t\ttokens.splice.apply(tokens, args);\r\n\t\t}\r\n\r\n\t\treturn new Prism.Token('interpolation', tokens, interpolationObject.alias, expression);\r\n\t}\r\n\r\n\t/**\r\n\t * Tokenizes the given code with support for JavaScript interpolation expressions mixed in.\r\n\t *\r\n\t * This function has 3 phases:\r\n\t *\r\n\t * 1. Replace all JavaScript interpolation expression with a placeholder.\r\n\t *    The placeholder will have the syntax of a identify of the target language.\r\n\t * 2. Tokenize the code with placeholders.\r\n\t * 3. Tokenize the interpolation expressions and re-insert them into the tokenize code.\r\n\t *    The insertion only works if a placeholder hasn't been \"ripped apart\" meaning that the placeholder has been\r\n\t *    tokenized as two tokens by the grammar of the embedded language.\r\n\t *\r\n\t * @param {string} code\r\n\t * @param {object} grammar\r\n\t * @param {string} language\r\n\t * @returns {Token}\r\n\t */\r\n\tfunction tokenizeEmbedded(code, grammar, language) {\r\n\t\t// 1. First filter out all interpolations\r\n\r\n\t\t// because they might be escaped, we need a lookbehind, so we use Prism\r\n\t\t/** @type {(Token|string)[]} */\r\n\t\tvar _tokens = Prism.tokenize(code, {\r\n\t\t\t'interpolation': {\r\n\t\t\t\tpattern: RegExp(interpolationPattern),\r\n\t\t\t\tlookbehind: true\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\t// replace all interpolations with a placeholder which is not in the code already\r\n\t\tvar placeholderCounter = 0;\r\n\t\t/** @type {Object<string, string>} */\r\n\t\tvar placeholderMap = {};\r\n\t\tvar embeddedCode = _tokens.map(function (token) {\r\n\t\t\tif (typeof token === 'string') {\r\n\t\t\t\treturn token;\r\n\t\t\t} else {\r\n\t\t\t\tvar interpolationExpression = token.content;\r\n\r\n\t\t\t\tvar placeholder;\r\n\t\t\t\twhile (code.indexOf(placeholder = getPlaceholder(placeholderCounter++, language)) !== -1) { /* noop */ }\r\n\t\t\t\tplaceholderMap[placeholder] = interpolationExpression;\r\n\t\t\t\treturn placeholder;\r\n\t\t\t}\r\n\t\t}).join('');\r\n\r\n\r\n\t\t// 2. Tokenize the embedded code\r\n\r\n\t\tvar embeddedTokens = tokenizeWithHooks(embeddedCode, grammar, language);\r\n\r\n\r\n\t\t// 3. Re-insert the interpolation\r\n\r\n\t\tvar placeholders = Object.keys(placeholderMap);\r\n\t\tplaceholderCounter = 0;\r\n\r\n\t\t/**\r\n\t\t *\r\n\t\t * @param {(Token|string)[]} tokens\r\n\t\t * @returns {void}\r\n\t\t */\r\n\t\tfunction walkTokens(tokens) {\r\n\t\t\tfor (var i = 0; i < tokens.length; i++) {\r\n\t\t\t\tif (placeholderCounter >= placeholders.length) {\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar token = tokens[i];\r\n\r\n\t\t\t\tif (typeof token === 'string' || typeof token.content === 'string') {\r\n\t\t\t\t\tvar placeholder = placeholders[placeholderCounter];\r\n\t\t\t\t\tvar s = typeof token === 'string' ? token : /** @type {string} */ (token.content);\r\n\r\n\t\t\t\t\tvar index = s.indexOf(placeholder);\r\n\t\t\t\t\tif (index !== -1) {\r\n\t\t\t\t\t\t++placeholderCounter;\r\n\r\n\t\t\t\t\t\tvar before = s.substring(0, index);\r\n\t\t\t\t\t\tvar middle = tokenizeInterpolationExpression(placeholderMap[placeholder]);\r\n\t\t\t\t\t\tvar after = s.substring(index + placeholder.length);\r\n\r\n\t\t\t\t\t\tvar replacement = [];\r\n\t\t\t\t\t\tif (before) {\r\n\t\t\t\t\t\t\treplacement.push(before);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\treplacement.push(middle);\r\n\t\t\t\t\t\tif (after) {\r\n\t\t\t\t\t\t\tvar afterTokens = [after];\r\n\t\t\t\t\t\t\twalkTokens(afterTokens);\r\n\t\t\t\t\t\t\treplacement.push.apply(replacement, afterTokens);\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif (typeof token === 'string') {\r\n\t\t\t\t\t\t\ttokens.splice.apply(tokens, [i, 1].concat(replacement));\r\n\t\t\t\t\t\t\ti += replacement.length - 1;\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\ttoken.content = replacement;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tvar content = token.content;\r\n\t\t\t\t\tif (Array.isArray(content)) {\r\n\t\t\t\t\t\twalkTokens(content);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\twalkTokens([content]);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\twalkTokens(embeddedTokens);\r\n\r\n\t\treturn new Prism.Token(language, embeddedTokens, 'language-' + language, code);\r\n\t}\r\n\r\n\t/**\r\n\t * The languages for which JS templating will handle tagged template literals.\r\n\t *\r\n\t * JS templating isn't active for only JavaScript but also related languages like TypeScript, JSX, and TSX.\r\n\t */\r\n\tvar supportedLanguages = {\r\n\t\t'javascript': true,\r\n\t\t'js': true,\r\n\t\t'typescript': true,\r\n\t\t'ts': true,\r\n\t\t'jsx': true,\r\n\t\t'tsx': true,\r\n\t};\r\n\tPrism.hooks.add('after-tokenize', function (env) {\r\n\t\tif (!(env.language in supportedLanguages)) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Finds and tokenizes all template strings with an embedded languages.\r\n\t\t *\r\n\t\t * @param {(Token | string)[]} tokens\r\n\t\t * @returns {void}\r\n\t\t */\r\n\t\tfunction findTemplateStrings(tokens) {\r\n\t\t\tfor (var i = 0, l = tokens.length; i < l; i++) {\r\n\t\t\t\tvar token = tokens[i];\r\n\r\n\t\t\t\tif (typeof token === 'string') {\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar content = token.content;\r\n\t\t\t\tif (!Array.isArray(content)) {\r\n\t\t\t\t\tif (typeof content !== 'string') {\r\n\t\t\t\t\t\tfindTemplateStrings([content]);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (token.type === 'template-string') {\r\n\t\t\t\t\t/**\r\n\t\t\t\t\t * A JavaScript template-string token will look like this:\r\n\t\t\t\t\t *\r\n\t\t\t\t\t * [\"template-string\", [\r\n\t\t\t\t\t *     [\"template-punctuation\", \"`\"],\r\n\t\t\t\t\t *     (\r\n\t\t\t\t\t *         An array of \"string\" and \"interpolation\" tokens. This is the simple string case.\r\n\t\t\t\t\t *         or\r\n\t\t\t\t\t *         [\"embedded-code\", \"...\"] This is the token containing the embedded code.\r\n\t\t\t\t\t *                                  It also has an alias which is the language of the embedded code.\r\n\t\t\t\t\t *     ),\r\n\t\t\t\t\t *     [\"template-punctuation\", \"`\"]\r\n\t\t\t\t\t * ]]\r\n\t\t\t\t\t */\r\n\r\n\t\t\t\t\tvar embedded = content[1];\r\n\t\t\t\t\tif (content.length === 3 && typeof embedded !== 'string' && embedded.type === 'embedded-code') {\r\n\t\t\t\t\t\t// get string content\r\n\t\t\t\t\t\tvar code = stringContent(embedded);\r\n\r\n\t\t\t\t\t\tvar alias = embedded.alias;\r\n\t\t\t\t\t\tvar language = Array.isArray(alias) ? alias[0] : alias;\r\n\r\n\t\t\t\t\t\tvar grammar = Prism.languages[language];\r\n\t\t\t\t\t\tif (!grammar) {\r\n\t\t\t\t\t\t\t// the embedded language isn't registered.\r\n\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tcontent[1] = tokenizeEmbedded(code, grammar, language);\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tfindTemplateStrings(content);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfindTemplateStrings(env.tokens);\r\n\t});\r\n\r\n\r\n\t/**\r\n\t * Returns the string content of a token or token stream.\r\n\t *\r\n\t * @param {string | Token | (string | Token)[]} value\r\n\t * @returns {string}\r\n\t */\r\n\tfunction stringContent(value) {\r\n\t\tif (typeof value === 'string') {\r\n\t\t\treturn value;\r\n\t\t} else if (Array.isArray(value)) {\r\n\t\t\treturn value.map(stringContent).join('');\r\n\t\t} else {\r\n\t\t\treturn stringContent(value.content);\r\n\t\t}\r\n\t}\r\n\r\n}(Prism));\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}